import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.39.3";

// ========================================================================
// TYPES & INTERFACES
// ========================================================================

interface ApiResponse {
  success: boolean;
  data?: any;
  error?: string;
}

interface TriggerWebhookRequest {
  order_id: string;
  event_type: string;
  product_id?: string; // DEPRECATED: NÃ£o mais necessÃ¡rio, mantido para compatibilidade
}

interface OrderItem {
  id: string;
  order_id: string;
  product_id: string;
  product_name: string;
  quantity: number;
  unit_price: number;
  total_price: number;
}

interface WebhookDispatchResult {
  webhook_id: string;
  webhook_name: string;
  product_id: string;
  product_name: string;
  success: boolean;
  result?: any;
  error?: string;
}

// ========================================================================
// CONSTANTS
// ========================================================================

const CORS_HEADERS = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type",
};

const ERROR_CODES = {
  UNAUTHORIZED: "UNAUTHORIZED",
  MISSING_FIELDS: "MISSING_FIELDS",
  ORDER_NOT_FOUND: "ORDER_NOT_FOUND",
  VENDOR_NOT_FOUND: "VENDOR_NOT_FOUND",
  ORDER_ITEMS_NOT_FOUND: "ORDER_ITEMS_NOT_FOUND",
  WEBHOOKS_FETCH_ERROR: "WEBHOOKS_FETCH_ERROR",
  DISPATCH_ERROR: "DISPATCH_ERROR",
  INTERNAL_ERROR: "INTERNAL_ERROR",
};

const DISPATCH_TIMEOUT = 30000; // 30 segundos

// ========================================================================
// HELPER FUNCTIONS - LOGGING
// ========================================================================

function logInfo(message: string, data?: any) {
  console.log(`[trigger-webhooks] [INFO] ${message}`, data ? JSON.stringify(data) : '');
}

function logError(message: string, error?: any) {
  console.error(`[trigger-webhooks] [ERROR] ${message}`, error);
}

function logWarn(message: string, data?: any) {
  console.warn(`[trigger-webhooks] [WARN] ${message}`, data ? JSON.stringify(data) : '');
}

// ========================================================================
// HELPER FUNCTIONS - RESPONSE
// ========================================================================

function createSuccessResponse(data: any): Response {
  return new Response(
    JSON.stringify({ success: true, data }),
    {
      headers: { ...CORS_HEADERS, "Content-Type": "application/json" },
      status: 200,
    }
  );
}

function createErrorResponse(code: string, message: string, status: number): Response {
  return new Response(
    JSON.stringify({ success: false, error: message, code }),
    {
      headers: { ...CORS_HEADERS, "Content-Type": "application/json" },
      status,
    }
  );
}

// ========================================================================
// HELPER FUNCTIONS - AUTH
// ========================================================================

function validateServiceRoleAuth(authHeader: string | null, serviceRoleKey: string | null): boolean {
  if (!authHeader || !serviceRoleKey) {
    return false;
  }

  const token = authHeader.replace("Bearer ", "");
  return token === serviceRoleKey;
}

// ========================================================================
// HELPER FUNCTIONS - WEBHOOK FILTERING
// ========================================================================

function filterWebhooksByEvent(webhooks: any[], eventType: string): any[] {
  return webhooks.filter((webhook: any) =>
    webhook.events && Array.isArray(webhook.events) && webhook.events.includes(eventType)
  );
}

function filterWebhooksByProduct(webhooks: any[], productId: string): any[] {
  return webhooks.filter((webhook: any) => {
    // VerificaÃ§Ã£o A: Tabela de Relacionamento (webhook_products)
    const hasRelation = webhook.webhook_products &&
      webhook.webhook_products.some((wp: any) => wp.product_id === productId);

    // VerificaÃ§Ã£o B: Coluna Antiga (product_id) - Compatibilidade
    const isLegacyMatch = webhook.product_id === productId;

    const matched = hasRelation || isLegacyMatch;

    if (matched) {
      logInfo('Webhook matched', {
        webhookId: webhook.id,
        webhookName: webhook.name,
        productId
      });
    }

    return matched;
  });
}

// ========================================================================
// HELPER FUNCTIONS - PAYLOAD BUILDER
// ========================================================================

function buildWebhookPayload(order: any, orderItem: OrderItem, eventType: string): any {
  return {
    event: eventType,
    order_id: order.id,
    customer: {
      name: order.customer_name,
      email: order.customer_email,
      phone: order.customer_phone,
      document: order.customer_document,
    },
    product: {
      id: orderItem.product_id,
      name: orderItem.product_name,
      quantity: orderItem.quantity,
      unit_price: orderItem.unit_price,
      total_price: orderItem.total_price,
    },
    payment: {
      method: order.payment_method,
      status: order.status,
      amount: order.total_amount,
      gateway_payment_id: order.gateway_payment_id,
    },
    created_at: order.created_at,
    updated_at: order.updated_at,
  };
}

// ========================================================================
// HELPER FUNCTIONS - DIRECT WEBHOOK DISPATCH
// ========================================================================

async function sendDirectToWebhook(
  webhook: any,
  orderId: string,
  eventType: string,
  payload: any,
  productId: string,
  productName: string,
  supabase: any
): Promise<WebhookDispatchResult> {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), DISPATCH_TIMEOUT);

  try {
    logInfo('ðŸ“¡ Enviando webhook diretamente', {
      webhookId: webhook.id,
      webhookName: webhook.name,
      productId,
      productName,
      url: webhook.url
    });

    // ðŸš€ DIRECT DELIVERY: Envia diretamente para o URL do cliente
    const response = await fetch(webhook.url, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        // TODO: Adicionar assinatura HMAC para seguranÃ§a
        // "X-Rise-Signature": generateHMAC(payload, webhook.secret)
      },
      body: JSON.stringify(payload),
      signal: controller.signal,
    });

    clearTimeout(timeoutId);

    // Capturar corpo da resposta
    let responseBody = "";
    try {
      const text = await response.text();
      responseBody = text.length > 1000 ? text.substring(0, 1000) + "..." : text;
    } catch (e) {
      responseBody = "[Sem corpo na resposta]";
    }

    const success = response.ok;
    const status = response.status;

    // ðŸ”¥ CORREÃ‡ÃƒO CRÃTICA: Salvar log com webhook_id para aparecer na interface
    const { error: dbError } = await supabase
      .from("webhook_deliveries")
      .insert({
        webhook_id: webhook.id,  // â† Essencial para logs aparecerem!
        order_id: orderId,
        event_type: eventType,
        payload: payload,
        status: success ? "success" : "failed",
        response_status: status,
        response_body: responseBody,
        attempts: 1
      });

    if (dbError) {
      logError('Erro ao salvar log de webhook', dbError);
    }

    if (success) {
      logInfo('âœ… Webhook enviado com sucesso', {
        webhookId: webhook.id,
        webhookName: webhook.name,
        productId,
        productName,
        status
      });
      return {
        webhook_id: webhook.id,
        webhook_name: webhook.name,
        product_id: productId,
        product_name: productName,
        success: true,
        result: { status, body: responseBody }
      };
    } else {
      logError('âŒ Webhook falhou', {
        webhookId: webhook.id,
        webhookName: webhook.name,
        productId,
        productName,
        status,
        body: responseBody
      });
      return {
        webhook_id: webhook.id,
        webhook_name: webhook.name,
        product_id: productId,
        product_name: productName,
        success: false,
        error: `HTTP ${status}: ${responseBody}`
      };
    }
  } catch (error: any) {
    clearTimeout(timeoutId);
    
    const isTimeout = error.name === 'AbortError';
    const errorMessage = isTimeout ? 'Timeout (30s)' : error.message;

    // Salvar erro no log
    await supabase
      .from("webhook_deliveries")
      .insert({
        webhook_id: webhook.id,
        order_id: orderId,
        event_type: eventType,
        payload: payload,
        status: "failed",
        response_status: 0,
        response_body: errorMessage,
        attempts: 1
      });

    logError('âŒ ExceÃ§Ã£o ao enviar webhook', {
      webhookId: webhook.id,
      error: errorMessage,
      isTimeout
    });

    return {
      webhook_id: webhook.id,
      webhook_name: webhook.name,
      product_id: productId,
      product_name: productName,
      success: false,
      error: errorMessage
    };
  }
}

// ========================================================================
// MAIN HANDLER
// ========================================================================

serve(async (req) => {
  // Handle CORS preflight
  if (req.method === "OPTIONS") {
    return new Response("ok", { headers: CORS_HEADERS });
  }

  try {
    logInfo('RequisiÃ§Ã£o recebida');

    // ========================================================================
    // 1. VALIDATE AUTHENTICATION
    // ========================================================================

    const authHeader = req.headers.get("authorization");
    const serviceRoleKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY");

    if (!validateServiceRoleAuth(authHeader, serviceRoleKey ?? null)) {
      logError('AutenticaÃ§Ã£o falhou');
      return createErrorResponse(
        ERROR_CODES.UNAUTHORIZED,
        "Unauthorized",
        401
      );
    }

    // ========================================================================
    // 2. INITIALIZE SUPABASE CLIENT
    // ========================================================================

    const supabaseUrl = Deno.env.get("SUPABASE_URL");

    if (!supabaseUrl || !serviceRoleKey) {
      throw new Error('VariÃ¡veis de ambiente nÃ£o configuradas');
    }

    const supabase = createClient(supabaseUrl, serviceRoleKey);

    // ========================================================================
    // 3. PARSE AND VALIDATE REQUEST
    // ========================================================================

    let requestData: TriggerWebhookRequest;

    try {
      requestData = await req.json();
    } catch (error) {
      logError('Erro ao fazer parse do JSON', error);
      return createErrorResponse(
        ERROR_CODES.MISSING_FIELDS,
        "Corpo da requisiÃ§Ã£o invÃ¡lido",
        400
      );
    }

    const { order_id, event_type, product_id } = requestData;

    if (!order_id || !event_type) {
      logError('Campos obrigatÃ³rios ausentes', { order_id, event_type });
      return createErrorResponse(
        ERROR_CODES.MISSING_FIELDS,
        "Missing required fields: order_id, event_type",
        400
      );
    }

    // ðŸš€ NOVO: product_id agora Ã© IGNORADO - vamos buscar todos os itens
    if (product_id) {
      logWarn('DEPRECATED: product_id foi passado mas serÃ¡ ignorado. Usando Busca Profunda de Itens.');
    }

    logInfo('Processando', { order_id, event_type });

    // ========================================================================
    // 4. FETCH ORDER
    // ========================================================================

    logInfo('Buscando pedido', { order_id });

    const { data: order, error: orderError } = await supabase
      .from("orders")
      .select("*")
      .eq("id", order_id)
      .maybeSingle();

    if (orderError) {
      logError('Erro ao buscar pedido', orderError);
      return createErrorResponse(
        ERROR_CODES.ORDER_NOT_FOUND,
        "Erro ao buscar pedido",
        500
      );
    }

    if (!order) {
      logWarn('Pedido nÃ£o encontrado', { order_id });
      return createErrorResponse(
        ERROR_CODES.ORDER_NOT_FOUND,
        "Order not found",
        404
      );
    }

    const vendorId = order.vendor_id;

    if (!vendorId) {
      logError('Vendor ID nÃ£o encontrado no pedido');
      return createErrorResponse(
        ERROR_CODES.VENDOR_NOT_FOUND,
        "Vendor ID not found",
        400
      );
    }

    logInfo('Pedido encontrado', { orderId: order.id, vendorId });

    // ========================================================================
    // 5. ðŸš€ BUSCA PROFUNDA DE ITENS (NOVO!)
    // ========================================================================

    logInfo('ðŸ” Buscando TODOS os itens do pedido (Busca Profunda)', { order_id });

    const { data: orderItems, error: itemsError } = await supabase
      .from("order_items")
      .select("*")
      .eq("order_id", order_id);

    if (itemsError) {
      logError('Erro ao buscar itens do pedido', itemsError);
      return createErrorResponse(
        ERROR_CODES.ORDER_ITEMS_NOT_FOUND,
        "Erro ao buscar itens do pedido",
        500
      );
    }

    // NOTA: Os bumps jÃ¡ estÃ£o em order_items com is_bump=true
    // NÃ£o precisamos buscar em order_bumps para evitar duplicaÃ§Ã£o
    logInfo('Bumps jÃ¡ estÃ£o em order_items (is_bump=true)', { order_id });
    
    const allItems = orderItems || [];

    if (!allItems || allItems.length === 0) {
      logWarn('Nenhum item encontrado no pedido', { order_id });
      return createErrorResponse(
        ERROR_CODES.ORDER_ITEMS_NOT_FOUND,
        "No items found in order",
        404
      );
    }

    logInfo('Itens encontrados', {
      order_id,
      itemCount: allItems.length,
      items: allItems.map((item: any) => ({
        product_id: item.product_id,
        product_name: item.product_name,
        is_bump: item.is_bump
      }))
    });

    // ========================================================================
    // 6. FETCH WEBHOOKS
    // ========================================================================

    logInfo('Buscando webhooks', { vendorId });

    const { data: allWebhooks, error: webhooksError } = await supabase
      .from("outbound_webhooks")
      .select(`
        *,
        webhook_products (
          product_id
        )
      `)
      .eq("vendor_id", vendorId)
      .eq("active", true);

    if (webhooksError) {
      logError('Erro ao buscar webhooks', webhooksError);
      return createErrorResponse(
        ERROR_CODES.WEBHOOKS_FETCH_ERROR,
        "Error fetching webhooks",
        500
      );
    }

    if (!allWebhooks || allWebhooks.length === 0) {
      logInfo('Nenhum webhook cadastrado');
      return createSuccessResponse({
        message: "No webhooks configured",
        webhooks_triggered: 0,
      });
    }

    // ========================================================================
    // 7. FILTER WEBHOOKS BY EVENT
    // ========================================================================

    const webhooksByEvent = filterWebhooksByEvent(allWebhooks, event_type);

    if (webhooksByEvent.length === 0) {
      logInfo('Nenhum webhook para este evento', { event_type });
      return createSuccessResponse({
        message: "No webhooks configured for this event",
        webhooks_triggered: 0,
      });
    }

    logInfo('Webhooks encontrados por evento', {
      count: webhooksByEvent.length,
      event_type
    });

    // ========================================================================
    // 8. ðŸš€ LOOP PELOS ITENS E DISPARA WEBHOOKS (NOVO!)
    // ========================================================================

    logInfo('ðŸ”„ Iniciando loop pelos itens do pedido', { itemCount: allItems.length });

    const allDispatchResults: WebhookDispatchResult[] = [];

    for (const orderItem of allItems) {
      logInfo('ðŸ“¦ Processando item', {
        product_id: orderItem.product_id,
        product_name: orderItem.product_name
      });

      // Filtrar webhooks para este produto especÃ­fico
      const matchedWebhooks = filterWebhooksByProduct(webhooksByEvent, orderItem.product_id);

      if (matchedWebhooks.length === 0) {
        logInfo('âš ï¸ Nenhum webhook correspondente para este produto', {
          product_id: orderItem.product_id,
          product_name: orderItem.product_name
        });
        continue;
      }

      logInfo('âœ… Webhooks correspondentes para este produto', {
        product_id: orderItem.product_id,
        product_name: orderItem.product_name,
        webhookCount: matchedWebhooks.length
      });

      // Construir payload especÃ­fico para este item
      const payload = buildWebhookPayload(order, orderItem, event_type);

      // Disparar webhooks para este item (Direct Delivery)
      const dispatchPromises = matchedWebhooks.map((webhook: any) =>
        sendDirectToWebhook(
          webhook,
          order.id,
          event_type,
          payload,
          orderItem.product_id,
          orderItem.product_name,
          supabase
        )
      );

      const itemResults = await Promise.all(dispatchPromises);
      allDispatchResults.push(...itemResults);

      logInfo('âœ… Webhooks disparados para este item', {
        product_id: orderItem.product_id,
        product_name: orderItem.product_name,
        total: matchedWebhooks.length,
        succeeded: itemResults.filter((r: WebhookDispatchResult) => r.success).length,
        failed: itemResults.filter((r: WebhookDispatchResult) => !r.success).length
      });
    }

    // ========================================================================
    // 9. RETURN RESULTS
    // ========================================================================

    const successCount = allDispatchResults.filter((r) => r.success).length;

    logInfo('ðŸŽ‰ Todos os webhooks foram processados', {
      totalItems: allItems.length,
      totalWebhooks: allDispatchResults.length,
      succeeded: successCount,
      failed: allDispatchResults.length - successCount
    });

    return createSuccessResponse({
      order_id: order.id,
      items_processed: allItems.length,
      webhooks_triggered: allDispatchResults.length,
      webhooks_succeeded: successCount,
      webhooks_failed: allDispatchResults.length - successCount,
      results: allDispatchResults,
    });

  } catch (error: any) {
    // ========================================================================
    // GLOBAL ERROR HANDLER
    // ========================================================================

    logError('Erro fatal nÃ£o tratado', {
      message: error.message,
      stack: error.stack,
    });

    return createErrorResponse(
      ERROR_CODES.INTERNAL_ERROR,
      "Erro interno do servidor",
      500
    );
  }
});
